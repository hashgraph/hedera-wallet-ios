//
//  Copyright 2020 Hedera Hashgraph LLC
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Foundation

/**
 A key to encrypt and decrypt the seed.

 This object is an asymmetric key pair used to protect the seed.  The seed is the actual binary object that the recovery phrase represents.

 Notes: This object has long-lasting operations and is not thread-safe.  It is recommended to use this object on a singular background thread.
 */
class SeedKey {
    // [RAS] FIXME: handle threading (by external callers)

    //
    // Implementation details
    //
    // The implementation is a 2048-bit RSA key pair generated by the operating system.  Through the design of the
    // `SecKey*` interfaces, the keys can be used to encrypt and decrypt the data even though they are never exposed to
    // user mode (i.e. the application never sees the key values).
    //
    // The public and private key handles are cached in this object on first use or upon request.
    //

    /// Specify use of the RSA algorithm
    private static let keyType = kSecAttrKeyTypeRSA

    /// Specify use of a 2048-bit key pair
    private static let keySizeInBits = 2048

    /// Tag by which the internal private key can be found later in the Keychain
    private static let privateTag = "com.hedera.wallet.keys.seed.private".data(using: .utf8)!

    /// Tag by which the internal public key can be found later in the Keychain
    private static let publicTag = "com.hedera.wallet.keys.seed.public".data(using: .utf8)!

    /// The instructions for creating the internal key pair.

    /// A cached handle to the private key
    private var privateKeyHandle: SecKey?

    /// A cached handle to the public key
    private var publicKeyHandle: SecKey?

    /// Gain access to the seed key if it already exists, and possibly create it if missing.
    init?(createIfMissing: Bool = false) {
        if SeedKey.exists() == .some(true) {
            privateKeyHandle = nil
            publicKeyHandle = nil
        }
        else {
            if !createIfMissing {
                return nil
            }
            let privateKeyHandleOpt = SeedKey.create()
            switch privateKeyHandleOpt {
            case .some(let privateKeyHandleVal):
                privateKeyHandle = privateKeyHandleVal
                publicKeyHandle = nil
            case .none:
                return nil
            }
        }
    }

    func encrypt(_ seed: Data) -> Data? {
        guard let publicKeyHandle = getPublicKeyHandle() else {
            return nil
        }
        let keySize = SecKeyGetBlockSize(publicKeyHandle)
        let PKCS1PADDING = 11
        guard 0 < seed.count && seed.count < keySize - PKCS1PADDING else {
            Logger.instance.log(message: "Bug: invalid seed data for encryption (size \(seed.count)).", event: .e)
            return nil
        }
        var encryptedSeed = [UInt8](repeating: 0, count: keySize)
        var outputCount = keySize
        let status = SecKeyEncrypt(publicKeyHandle, .PKCS1, Array(seed), seed.count, &encryptedSeed, &outputCount)
        guard status == errSecSuccess else {
            Logger.instance.log(message: "Unexpected failure encrypting seed.", event: .e)
            return nil
        }
        return Data(bytes: UnsafePointer<UInt8>(encryptedSeed), count: outputCount)
    }

    func decrypt(_ encryptedSeed: Data) -> Data? {
        guard let privateKeyHandle = getPrivateKeyHandle() else {
            return nil
        }
        let keySize: Int = SecKeyGetBlockSize(privateKeyHandle)
        guard encryptedSeed.count == keySize else {
            Logger.instance.log(message: "Invalid block for decryption (size \(encryptedSeed.count)).", event: .e)
            return nil
        }
        var seed = [UInt8](repeating: 0, count: keySize)
        var outputCount = keySize
        let status = SecKeyDecrypt(privateKeyHandle, .PKCS1, Array(encryptedSeed), encryptedSeed.count,
                                   &seed, &outputCount)
        guard status == errSecSuccess else {
            Logger.instance.log(message: "Unexpected failure decrypting seed.", event: .e)
            return nil
        }
        return Data(bytes: UnsafePointer<UInt8>(seed), count: outputCount)
    }

    /// Delete the seed key pair if it exists.
    static func delete() -> Bool? {
        let first = delete(withTag: privateTag)
        let second = delete(withTag: publicTag)
        switch first {
        case .some(false): return second
        case .some(true):
            switch second {
            case .some(_): return .some(true)
            case .none: return .none
            }
        case .none: return .none
        }
    }

    /// Actual mechanism to create the key pair.  Returns the private key handle.
    private static func create() -> SecKey? {
        let attributes: [CFString: Any] = [
            kSecAttrKeyType: kSecAttrKeyTypeRSA,
            kSecAttrKeySizeInBits: 2048,
            kSecPrivateKeyAttrs: [
                kSecAttrIsPermanent: true,
                kSecAttrApplicationTag: SeedKey.privateTag
            ],
            kSecPublicKeyAttrs: [
                kSecAttrIsPermanent: true,
                kSecAttrApplicationTag: SeedKey.publicTag
            ]
        ]
        var error: Unmanaged<CFError>? = nil
        guard let privateKeyHandle = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {
            guard let cferror = error?.takeRetainedValue() else {
                return nil
            }
            let code =  OSStatus(CFErrorGetCode(cferror))
            switch code {
            case errSecParam, errSecUserCanceled, errSecBadReq:
                // We probably did something wrong.
                Logger.instance.log(message: "Bug calling SecKeyCreateRandomKey.\n\(code)", event: .e)
            default:
                // More likely there was a system problem.
                Logger.instance.log(message: "Unexpected failure of SecKeyCreateRandomKey.\n\(code)", event: .e)
            }
            return nil
        }
        return privateKeyHandle
    }

    /// Actual mechanism to delete one of the keys.
    private static func delete(withTag tag: Data) -> Bool? {
        let query: [CFString: Any] = [
            kSecClass: kSecClassKey,
            kSecAttrKeyType: kSecAttrKeyTypeRSA,
            kSecAttrApplicationTag: tag
        ]
        let status = SecItemDelete(query as CFDictionary)
        switch status {
        case errSecSuccess: return .some(true)
        case errSecItemNotFound: return .some(false)
        default:
            Logger.instance.log(message: "Unexpected failure of SecKeyDelete.\n\(status)", event: .w)
            return .none
        }
    }

    /// Test if the seed key exists.
    private static func exists() -> Bool? {
        let query: [CFString: Any] = [
            kSecClass: kSecClassKey,
            kSecAttrKeyType: kSecAttrKeyTypeRSA,
            kSecAttrApplicationTag: SeedKey.publicTag
        ]
        let status = SecItemCopyMatching(query as CFDictionary, nil)
        switch status {
        case errSecSuccess: return .some(true)
        case errSecItemNotFound: return .some(false)
        default:
            Logger.instance.log(message: "Unexpected failure of SecItemCopyMatching.\n\(status)", event: .e)
            return .none
        }
    }

    private func getPrivateKeyHandle() -> SecKey? {
        if privateKeyHandle == nil {
            privateKeyHandle = SeedKey.get(withTag: SeedKey.privateTag)
        }
        return privateKeyHandle
    }

    private func getPublicKeyHandle() -> SecKey? {
        if publicKeyHandle == nil {
            publicKeyHandle = SeedKey.get(withTag: SeedKey.publicTag)
        }
        return publicKeyHandle
    }

    private static func get(withTag tag: Data) -> SecKey? {
        let query: [CFString: Any] = [
            kSecReturnRef: true,
            kSecClass: kSecClassKey,
            kSecAttrKeyType: kSecAttrKeyTypeRSA,
            kSecAttrApplicationTag: tag
        ]
        var result: CFTypeRef? = nil
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        guard status == errSecSuccess else {
            if status == errSecItemNotFound {
                return .none
            }
            Logger.instance.log(message: "Unexpected failure of SecItemCopyMatching.\n\(status)", event: .e)
            return .none
        }
        let key = result.flatMap { SecKeyGetTypeID() == CFGetTypeID($0) ? .some($0 as! SecKey) : .none }
        guard key != nil else {
            Logger.instance.log(message: "Unexpected return value from SecItemCopyMatching.", event: .e)
            return .none
        }
        return key
    }
}
